package pkg_telquel { 
	rule telquel_0 { 
		pattern { T[lemma="tel"] ; Q[lemma="quel"] ;
			T < Q }
		without { T -[fixed]-> Q } % no loop
		commands {
			add_node T2 :< T ; add_node Q2 :< Q ; 
			append_feats T ==> T2 ;
			T2.form = T.form ; T2.lemma = T.lemma ; T2.upos = "ADJ" ;
			append_feats Q ==> Q2 ;
			Q2.form = Q.form ; Q2.lemma = Q.lemma ; Q2.upos = "ADJ" ;
			shift Q ==> T2 ; shift T ==> T2 ;
			T2.ExtPos = "ADJ" ; add_edge T2 -[fixed]-> Q2 ;
			del_node T ; del_node Q
			}
		}
	}
strat telquel { Onf(Seq(pkg_telquel)) }

package pkg_nimporte { 
	rule nimporte_0 { 
		pattern { N[lemma="ne"] ; I[form="importe"] ;
			WH[lemma="qui"|"quoi"|"quel"|"où"|"quand"|"comment"|"lequel"] ;
			N < I ; I < WH }
		without { N -[fixed]-> I ;  N -[fixed]-> WH } % no loop
		pattern  { WH[lemma="quoi"|"qui"|"lequel"] }
		without { ANCHOR -[1=advcl|ccomp|parataxis|dep]-> I }
		commands {
			add_node N2 :< N ; add_node I2 :< I ;
			add_node WH2 :< WH ;
			append_feats N ==> N2 ;
			N2.form = N.form ; N2.lemma = N.lemma ; N2.upos = N.upos ;
			append_feats I ==> I2 ;
			I2.form = I.form ; I2.lemma = I.lemma ; I2.upos = I.upos ;
			append_feats WH ==> WH2 ;
			WH2.form = WH.form ; WH2.lemma = WH.lemma ; WH2.upos = WH.upos ;
			shift N ==> N2 ; shift I ==> N2 ; shift WH ==> N2 ;
			add_edge N2 -[fixed]-> I2 ; add_edge N2 -[fixed]-> WH2 ;
			del_node N ; del_node I ; del_node WH ;
			N2.ExtPos = "PRON" ;
			}
		}
	rule nimporte_1 { 
		pattern { N[lemma="ne"] ; I[form="importe"] ;
			WH[lemma="qui"|"quoi"|"quel"|"où"|"quand"|"comment"|"lequel"] ;
			N < I ; I < WH }
		without { N -[fixed]-> I ;  N -[fixed]-> WH } % no loop
		pattern  { WH[lemma="quoi"|"qui"|"lequel"] }
		pattern { ANCHOR -[advcl|ccomp|parataxis]-> I }
		without { I -[case|mark]-> C }
		commands {
			add_node N2 :< N ; add_node I2 :< I ;
			add_node WH2 :< WH ;
			append_feats N ==> N2 ;
			N2.form = N.form ; N2.lemma = N.lemma ; N2.upos = N.upos ;
			append_feats I ==> I2 ;
			I2.form = I.form ; I2.lemma = I.lemma ; I2.upos = I.upos ;
			append_feats WH ==> WH2 ;
			WH2.form = WH.form ; WH2.lemma = WH.lemma ; WH2.upos = WH.upos ;
			shift N ==> N2 ; shift I ==> N2 ; shift WH ==> N2 ;
			add_edge N2 -[fixed]-> I2 ; add_edge N2 -[fixed]-> WH2 ;
			del_node N ; del_node I ; del_node WH ;
			N2.ExtPos = "PRON" ;
			add_edge ANCHOR -[obj]-> N2
			}
		}
	rule nimporte_2 { 
		pattern { N[lemma="ne"] ; I[form="importe"] ;
			WH[lemma="qui"|"quoi"|"quel"|"où"|"quand"|"comment"|"lequel"] ;
			N < I ; I < WH }
		without { N -[fixed]-> I ;  N -[fixed]-> WH } % no loop
		pattern  { WH[lemma="quoi"|"qui"|"lequel"] }
		pattern { ANCHOR -[advcl|ccomp|parataxis]-> I ;
			I -[case|mark]-> C ; C[upos="ADP"] }
		commands {
			add_node N2 :< N ; add_node I2 :< I ;
			add_node WH2 :< WH ;
			append_feats N ==> N2 ;
			N2.form = N.form ; N2.lemma = N.lemma ; N2.upos = N.upos ;
			append_feats I ==> I2 ;
			I2.form = I.form ; I2.lemma = I.lemma ; I2.upos = I.upos ;
			append_feats WH ==> WH2 ;
			WH2.form = WH.form ; WH2.lemma = WH.lemma ; WH2.upos = WH.upos ;
			shift N ==> N2 ; shift I ==> N2 ; shift WH ==> N2 ;
			add_edge N2 -[fixed]-> I2 ; add_edge N2 -[fixed]-> WH2 ;
			del_node N ; del_node I ; del_node WH ;
			N2.ExtPos = "PRON" ;
			add_edge ANCHOR -[obl]-> N2 ;
			add_edge N2 -[case]-> C
			}
		}
	rule nimporte_3 { 
		pattern { N[lemma="ne"] ; I[form="importe"] ;
			WH[lemma="qui"|"quoi"|"quel"|"où"|"quand"|"comment"|"lequel"] ;
			N < I ; I < WH }
		without { N -[fixed]-> I ;  N -[fixed]-> WH } % no loop
		pattern  { WH[lemma="quel"] ;
			I -[1=nsubj|obj]-> S }
		without { ANCHOR -[1=advcl|ccomp|parataxis|dep]-> I }
		commands {
			add_node N2 :< N ; add_node I2 :< I ;
			add_node WH2 :< WH ;
			append_feats N ==> N2 ;
			N2.form = N.form ; N2.lemma = N.lemma ; N2.upos = N.upos ;
			append_feats I ==> I2 ;
			I2.form = I.form ; I2.lemma = I.lemma ; I2.upos = I.upos ;
			append_feats WH ==> WH2 ;
			WH2.form = WH.form ; WH2.lemma = WH.lemma ; WH2.upos = WH.upos ;
			shift N ==> N2 ; shift I ==> N2 ; shift WH ==> N2 ;
			add_edge N2 -[fixed]-> I2 ; add_edge N2 -[fixed]-> WH2 ;
			del_node N ; del_node I ; del_node WH ;
			N2.ExtPos = "DET" ;
			del_edge N2 -[obj]-> S ; del_edge S -[nsubj]-> N2 ; shift N2 =[^fixed]=> S ;
			add_edge S -[det]-> N2 ;
			}
		}
	rule nimporte_4 { 
		pattern { N[lemma="ne"] ; I[form="importe"] ;
			WH[lemma="qui"|"quoi"|"quel"|"où"|"quand"|"comment"|"lequel"] ;
			N < I ; I < WH }
		without { N -[fixed]-> I ;  N -[fixed]-> WH } % no loop
		pattern  { WH[lemma="quel"] ;
			I -[1=nsubj|obj]-> S }
		pattern { ANCHOR -[advcl|ccomp|parataxis]-> I }
		without { I -[case|mark]-> C }
		commands {
			add_node N2 :< N ; add_node I2 :< I ;
			add_node WH2 :< WH ;
			append_feats N ==> N2 ;
			N2.form = N.form ; N2.lemma = N.lemma ; N2.upos = N.upos ;
			append_feats I ==> I2 ;
			I2.form = I.form ; I2.lemma = I.lemma ; I2.upos = I.upos ;
			append_feats WH ==> WH2 ;
			WH2.form = WH.form ; WH2.lemma = WH.lemma ; WH2.upos = WH.upos ;
			shift N ==> N2 ; shift I ==> N2 ; shift WH ==> N2 ;
			add_edge N2 -[fixed]-> I2 ; add_edge N2 -[fixed]-> WH2 ;
			del_node N ; del_node I ; del_node WH ;
			N2.ExtPos = "DET" ;
			del_edge N2 -[obj]-> S ; del_edge S -[nsubj]-> N2 ; shift N2 =[^fixed]=> S ;
			add_edge S -[det]-> N2 ;
			add_edge ANCHOR -[obj]-> S
			}
		}
	rule nimporte_5 { 
		pattern { N[lemma="ne"] ; I[form="importe"] ;
			WH[lemma="qui"|"quoi"|"quel"|"où"|"quand"|"comment"|"lequel"] ;
			N < I ; I < WH }
		without { N -[fixed]-> I ;  N -[fixed]-> WH } % no loop
		pattern  { WH[lemma="quel"] ;
			I -[1=nsubj|obj]-> S }
		pattern { ANCHOR -[advcl|ccomp|parataxis]-> I ;
			I -[case|mark]-> C ; C[upos="ADP"] }
		commands {
			add_node N2 :< N ; add_node I2 :< I ;
			add_node WH2 :< WH ;
			append_feats N ==> N2 ;
			N2.form = N.form ; N2.lemma = N.lemma ; N2.upos = N.upos ;
			append_feats I ==> I2 ;
			I2.form = I.form ; I2.lemma = I.lemma ; I2.upos = I.upos ;
			append_feats WH ==> WH2 ;
			WH2.form = WH.form ; WH2.lemma = WH.lemma ; WH2.upos = WH.upos ;
			shift N ==> N2 ; shift I ==> N2 ; shift WH ==> N2 ;
			add_edge N2 -[fixed]-> I2 ; add_edge N2 -[fixed]-> WH2 ;
			del_node N ; del_node I ; del_node WH ;
			N2.ExtPos = "DET" ;
			del_edge N2 -[obj]-> S ; del_edge S -[nsubj]-> N2 ; shift N2 =[^fixed]=> S ;
			add_edge S -[det]-> N2 ;
			add_edge ANCHOR -[obl]-> S ;
			add_edge S -[case]-> C
			}
		}
	rule nimporte_6 { 
		pattern { N[lemma="ne"] ; I[form="importe"] ;
			WH[lemma="qui"|"quoi"|"quel"|"où"|"quand"|"comment"|"lequel"] ;
			N < I ; I < WH }
		without { N -[fixed]-> I ;  N -[fixed]-> WH } % no loop
		pattern  { WH[lemma="quand"|"où"|"comment"] }
		without { ANCHOR -[1=advcl|ccomp|parataxis|dep]-> I }
		commands {
			add_node N2 :< N ; add_node I2 :< I ;
			add_node WH2 :< WH ;
			append_feats N ==> N2 ;
			N2.form = N.form ; N2.lemma = N.lemma ; N2.upos = N.upos ;
			append_feats I ==> I2 ;
			I2.form = I.form ; I2.lemma = I.lemma ; I2.upos = I.upos ;
			append_feats WH ==> WH2 ;
			WH2.form = WH.form ; WH2.lemma = WH.lemma ; WH2.upos = WH.upos ;
			shift N ==> N2 ; shift I ==> N2 ; shift WH ==> N2 ;
			add_edge N2 -[fixed]-> I2 ; add_edge N2 -[fixed]-> WH2 ;
			del_node N ; del_node I ; del_node WH ;
			N2.ExtPos = "ADV" ;
			}
		}
	rule nimporte_7 { 
		pattern { N[lemma="ne"] ; I[form="importe"] ;
			WH[lemma="qui"|"quoi"|"quel"|"où"|"quand"|"comment"|"lequel"] ;
			N < I ; I < WH }
		without { N -[fixed]-> I ;  N -[fixed]-> WH } % no loop
		pattern  { WH[lemma="quand"|"où"|"comment"] }
		pattern { ANCHOR -[advcl|ccomp|parataxis]-> I ;
			WH[lemma="quand"|"où"|"comment"] }
		commands {
			add_node N2 :< N ; add_node I2 :< I ;
			add_node WH2 :< WH ;
			append_feats N ==> N2 ;
			N2.form = N.form ; N2.lemma = N.lemma ; N2.upos = N.upos ;
			append_feats I ==> I2 ;
			I2.form = I.form ; I2.lemma = I.lemma ; I2.upos = I.upos ;
			append_feats WH ==> WH2 ;
			WH2.form = WH.form ; WH2.lemma = WH.lemma ; WH2.upos = WH.upos ;
			shift N ==> N2 ; shift I ==> N2 ; shift WH ==> N2 ;
			add_edge N2 -[fixed]-> I2 ; add_edge N2 -[fixed]-> WH2 ;
			del_node N ; del_node I ; del_node WH ;
			N2.ExtPos = "ADV" ;
			add_edge ANCHOR -[advmod]-> N2
			}
		}
	}
strat nimporte { Onf(Seq(pkg_nimporte)) }

package pkg_whque { 
	rule whque_0 { 
		pattern {
			WH[lemma="quel"|"qui"|"quoi"|"lequel"|"où"|"quand"] ; Q[lemma="que"] ;
		WH < Q }
		without { WH.PronType = "Rel" } % no loop
		pattern { C[lemma="ce"] ; Q < C }
		commands {
			WH.PronType = "Rel"
			}
		}
	rule whque_1 { 
		pattern {
			WH[lemma="quel"|"qui"|"quoi"|"lequel"|"où"|"quand"] ; Q[lemma="que"] ;
		WH < Q }
		without { WH.PronType = "Rel" } % no loop
		pattern { WH[lemma="quel"] }
		commands {
			WH.PronType = "Rel"
			}
		}
	}
strat whque { Onf(Seq(pkg_whque)) }

package pkg_relprontype { 
	rule relprontype_0 { 
		pattern {
			WH[lemma="qui"|"que"|"quoi"|"où"|"lequel",!PronType] ;
			ANCHOR -[acl:relcl|advcl:cleft]-> CL_HEAD ; WH << CL_HEAD }
		pattern { CL_HEAD -> WH }
		commands {
			WH.PronType="Rel"
			}
		}
	rule relprontype_1 { 
		pattern {
			WH[lemma="qui"|"que"|"quoi"|"où"|"lequel",!PronType] ;
			ANCHOR -[acl:relcl|advcl:cleft]-> CL_HEAD ; WH << CL_HEAD }
		pattern { CL_HEAD -> I  ; I -> WH ; I << WH }
		commands {
			WH.PronType="Rel"
			}
		}
	rule relprontype_2 { 
		pattern {
			WH[lemma="qui"|"que"|"quoi"|"où"|"lequel",!PronType] ;
			ANCHOR -[acl:relcl|advcl:cleft]-> CL_HEAD ; WH << CL_HEAD }
		pattern { CL_HEAD -> I  ; I -> WH ; CL_HEAD << I}
		commands {
			WH.PronType="Rel"
			}
		}
	rule relprontype_3 { 
		pattern {
			WH[lemma="qui"|"que"|"quoi"|"où"|"lequel",!PronType] ;
			ANCHOR -[acl:relcl|advcl:cleft]-> CL_HEAD ; WH << CL_HEAD }
		pattern { CL_HEAD -> V ; V -> PH_HEAD ;
			PH_HEAD -> WH ; PH_HEAD << WH ; CL_HEAD << V }
		commands {
			WH.PronType="Rel"
			}
		}
	}
strat relprontype { Onf(Seq(pkg_relprontype)) }

package pkg_intprontype { 
	rule intprontype_0 { 
		pattern {
			WH[lemma="qui"|"que"|"quoi"|"comment"|"où"|"quand"|"combien"|"pourquoi"|"lequel"|"quel",!PronType]}
		pattern {
			WH [lemma="quel",upos="ADJ"|"DET"|"PRON"] }
			without { Q [lemma="que"] ; WH < Q }
			without { A [form="n'"] ; B[form="importe"] ; A < B ; B < WH }
			without { T[form="tel"] ; T < WH }
			without { E[lemma="!"] }
		commands {
			WH.PronType="Int"
			}
		}
	rule intprontype_1 { 
		pattern {
			WH[lemma="qui"|"que"|"quoi"|"comment"|"où"|"quand"|"combien"|"pourquoi"|"lequel"|"quel",!PronType]}
		pattern {
			WH[lemma="comment"|"combien", upos="ADV"]}
		commands {
			WH.PronType="Int"
			}
		}
	rule intprontype_2 { 
		pattern {
			WH[lemma="qui"|"que"|"quoi"|"comment"|"où"|"quand"|"combien"|"pourquoi"|"lequel"|"quel",!PronType]}
		pattern { WH[lemma="pourquoi", upos="ADV"]}
		without { C[lemma="ce"] ; E[lemma="être"] ; C < E ; E < WH } % not "c'est pourquoi"
		commands {
			WH.PronType="Int"
			}
		}
	rule intprontype_3 { 
		pattern {
			WH[lemma="qui"|"que"|"quoi"|"comment"|"où"|"quand"|"combien"|"pourquoi"|"lequel"|"quel",!PronType]}
		pattern { WH[lemma="quand", upos="ADV"]}
		without { M[lemma="même"] ; WH < M } % not "quand même"
		without { B[lemma="bien"] ; M[lemma="même"] ; WH < B ; B < M } % not "quand bien même"
		without { G -[mark]-> WH } %% bad annotation of "quand" which should be SCONJ
		commands {
			WH.PronType="Int"
			}
		}
	rule intprontype_4 { 
		pattern {
			WH[lemma="qui"|"que"|"quoi"|"comment"|"où"|"quand"|"combien"|"pourquoi"|"lequel"|"quel",!PronType]}
		pattern { WH[lemma="où", upos="ADV"]}
		without { WH -[ccomp]-> V } % badly annotated relative clause
		commands {
			WH.PronType="Int"
			}
		}
	rule intprontype_5 { 
		pattern {
			WH[lemma="qui"|"que"|"quoi"|"comment"|"où"|"quand"|"combien"|"pourquoi"|"lequel"|"quel",!PronType]}
		pattern { WH[lemma="lequel", upos="PRON"]}
		commands {
			WH.PronType="Int"
			}
		}
	rule intprontype_6 { 
		pattern {
			WH[lemma="qui"|"que"|"quoi"|"comment"|"où"|"quand"|"combien"|"pourquoi"|"lequel"|"quel",!PronType]}
		pattern {
			WH[lemma="qui"|"que"|"quoi", upos="PRON"]}
		without { C[lemma="ce"] ; WH[lemma="que"] ; C < WH } % no "ce que"
		without { G -[discourse]-> WH ; WH[lemma="quoi"] } % no interjection "quoi" (should be INTJ)
		without { N1[lemma="que"]; N2[lemma="ce"]; N3[form="soit"];
			WH < N1 ; N1 < N2; N2 < N3; } % no "qui/quoi que ce soit"
		without { N1[lemma="en"]; N2[lemma="ce"]; N3[form="concerne"];
			N1 < N2; N2 < WH; WH < N3 } % no "en ce qui concerne"
		without { E[lemma="!"] } % Not exclamative
		commands {
			WH.PronType="Int"
			}
		}
	}
strat intprontype { Onf(Seq(pkg_intprontype)) }

package pkg_qecq { 
	rule qecq_0 { 
		pattern { WH[lemma="que"] ; E[form="est"] ;
			C[form="ce"|"-ce"] ; Q[lemma="que"|"qui"] ;
			WH < E ; E < C ; C < Q }
		without { WH -[fixed]-> E ; WH -[fixed]-> C ; WH -[fixed]-> Q } % Avoiding looping
		without { WH -[dislocated]-> N }
		pattern { CE [lemma="ce"]; COP [lemma="être"];
			Q < CE ; CE < COP }
		commands {
			add_node WH2 :< WH ; add_node E2 :> WH ;
			add_node C2 :> E2 ; add_node Q2 :> C2 ;
			append_feats WH ==> WH2 ; shift WH ==> WH2 ; WH2.ExtPos = "PRON" ;
			shift E ==> E2 ;
			WH2.form = WH.form ; WH2.lemma = WH.lemma ; WH2.upos = WH.upos ;
			append_feats E ==> E2 ;
			E2.form = E.form ; E2.lemma = E.lemma ; E2.upos = E.upos ;
			append_feats C ==> C2 ;
			C2.form = C.form ; C2.lemma = C.lemma ; C2.upos = C.upos ;
			append_feats Q ==> Q2 ;
			Q2.form = Q.form ; Q2.lemma = Q.lemma ; Q2.upos = Q.upos ;
			add_edge WH2 -[fixed]-> E2 ; add_edge WH2 -[fixed]-> C2 ;
			add_edge WH2 -[fixed]-> Q2 ;
			del_node WH ; del_node E ; del_node C ; del_node Q ;
			add_node CE2 :> Q2 ; add_node COP2 :> CE2 ;
			append_feats CE ==> CE2 ;
			CE2.form = CE.form ; CE2.lemma = CE.lemma ; CE2.upos = CE.upos ;
			append_feats COP ==> COP2 ;
			COP2.form = COP.form ; COP2.lemma = COP.lemma ; COP2.upos = COP.upos ;
			add_edge WH2 -[nsubj]-> CE2 ; add_edge WH2 -[cop]-> COP2 ;
			del_node CE ; del_node COP ; 
			}
		}
	rule qecq_1 { 
		pattern { WH[lemma="que"] ; E[form="est"] ;
			C[form="ce"|"-ce"] ; Q[lemma="que"|"qui"] ;
			WH < E ; E < C ; C < Q }
		without { WH -[fixed]-> E ; WH -[fixed]-> C ; WH -[fixed]-> Q } % Avoiding looping
		without { WH -[dislocated]-> N }
		pattern { h: WH -[1=advcl|dislocated|ccomp]-> CL_HEAD }
		pattern { Q[lemma="que"] }
		pattern { CL_HEAD -[xcomp]-> V }
		commands {
			add_node WH2 :< WH ; add_node E2 :> WH ;
			add_node C2 :> E2 ; add_node Q2 :> C2 ;
			append_feats WH ==> WH2 ; shift WH ==> WH2 ; WH2.ExtPos = "PRON" ;
			shift E ==> E2 ;
			WH2.form = WH.form ; WH2.lemma = WH.lemma ; WH2.upos = WH.upos ;
			append_feats E ==> E2 ;
			E2.form = E.form ; E2.lemma = E.lemma ; E2.upos = E.upos ;
			append_feats C ==> C2 ;
			C2.form = C.form ; C2.lemma = C.lemma ; C2.upos = C.upos ;
			append_feats Q ==> Q2 ;
			Q2.form = Q.form ; Q2.lemma = Q.lemma ; Q2.upos = Q.upos ;
			add_edge WH2 -[fixed]-> E2 ; add_edge WH2 -[fixed]-> C2 ;
			add_edge WH2 -[fixed]-> Q2 ;
			del_node WH ; del_node E ; del_node C ; del_node Q ;
			shift WH2 =[^fixed]=> CL_HEAD ;
			add_edge V -[obj]-> WH2 ;
			}
		}
	rule qecq_2 { 
		pattern { WH[lemma="que"] ; E[form="est"] ;
			C[form="ce"|"-ce"] ; Q[lemma="que"|"qui"] ;
			WH < E ; E < C ; C < Q }
		without { WH -[fixed]-> E ; WH -[fixed]-> C ; WH -[fixed]-> Q } % Avoiding looping
		without { WH -[dislocated]-> N }
		pattern { h: WH -[1=advcl|dislocated|ccomp]-> CL_HEAD }
		pattern { Q[lemma="que"] }
		without { CL_HEAD -[xcomp]-> V }
		commands {
			add_node WH2 :< WH ; add_node E2 :> WH ;
			add_node C2 :> E2 ; add_node Q2 :> C2 ;
			append_feats WH ==> WH2 ; shift WH ==> WH2 ; WH2.ExtPos = "PRON" ;
			shift E ==> E2 ;
			WH2.form = WH.form ; WH2.lemma = WH.lemma ; WH2.upos = WH.upos ;
			append_feats E ==> E2 ;
			E2.form = E.form ; E2.lemma = E.lemma ; E2.upos = E.upos ;
			append_feats C ==> C2 ;
			C2.form = C.form ; C2.lemma = C.lemma ; C2.upos = C.upos ;
			append_feats Q ==> Q2 ;
			Q2.form = Q.form ; Q2.lemma = Q.lemma ; Q2.upos = Q.upos ;
			add_edge WH2 -[fixed]-> E2 ; add_edge WH2 -[fixed]-> C2 ;
			add_edge WH2 -[fixed]-> Q2 ;
			del_node WH ; del_node E ; del_node C ; del_node Q ;
			shift WH2 =[^fixed]=> CL_HEAD ;
			add_edge CL_HEAD -[obj]-> WH2 ;
			}
		}
	rule qecq_3 { 
		pattern { WH[lemma="que"] ; E[form="est"] ;
			C[form="ce"|"-ce"] ; Q[lemma="que"|"qui"] ;
			WH < E ; E < C ; C < Q }
		without { WH -[fixed]-> E ; WH -[fixed]-> C ; WH -[fixed]-> Q } % Avoiding looping
		without { WH -[dislocated]-> N }
		pattern { h: WH -[1=advcl|dislocated|ccomp]-> CL_HEAD }
		pattern { Q[lemma="qui"] }
		commands {
			add_node WH2 :< WH ; add_node E2 :> WH ;
			add_node C2 :> E2 ; add_node Q2 :> C2 ;
			append_feats WH ==> WH2 ; shift WH ==> WH2 ; WH2.ExtPos = "PRON" ;
			shift E ==> E2 ;
			WH2.form = WH.form ; WH2.lemma = WH.lemma ; WH2.upos = WH.upos ;
			append_feats E ==> E2 ;
			E2.form = E.form ; E2.lemma = E.lemma ; E2.upos = E.upos ;
			append_feats C ==> C2 ;
			C2.form = C.form ; C2.lemma = C.lemma ; C2.upos = C.upos ;
			append_feats Q ==> Q2 ;
			Q2.form = Q.form ; Q2.lemma = Q.lemma ; Q2.upos = Q.upos ;
			add_edge WH2 -[fixed]-> E2 ; add_edge WH2 -[fixed]-> C2 ;
			add_edge WH2 -[fixed]-> Q2 ;
			del_node WH ; del_node E ; del_node C ; del_node Q ;
			shift WH2 =[^fixed]=> CL_HEAD ;
			add_edge CL_HEAD -[nsubj]-> WH2 ;
			}
		}
	rule qecq_4 { 
		pattern { WH[lemma="que"] ; E[form="est"] ;
			C[form="ce"|"-ce"] ; Q[lemma="que"|"qui"] ;
			WH < E ; E < C ; C < Q }
		without { WH -[fixed]-> E ; WH -[fixed]-> C ; WH -[fixed]-> Q } % Avoiding looping
		without { WH -[dislocated]-> N }
		pattern { h: E -[1=advcl|dislocated|ccomp]-> CL_HEAD }
		pattern { Q[lemma="que"] }
		pattern { CL_HEAD -[xcomp]-> V }
		commands {
			add_node WH2 :< WH ; add_node E2 :> WH ;
			add_node C2 :> E2 ; add_node Q2 :> C2 ;
			append_feats WH ==> WH2 ; shift WH ==> WH2 ; WH2.ExtPos = "PRON" ;
			shift E ==> E2 ;
			WH2.form = WH.form ; WH2.lemma = WH.lemma ; WH2.upos = WH.upos ;
			append_feats E ==> E2 ;
			E2.form = E.form ; E2.lemma = E.lemma ; E2.upos = E.upos ;
			append_feats C ==> C2 ;
			C2.form = C.form ; C2.lemma = C.lemma ; C2.upos = C.upos ;
			append_feats Q ==> Q2 ;
			Q2.form = Q.form ; Q2.lemma = Q.lemma ; Q2.upos = Q.upos ;
			add_edge WH2 -[fixed]-> E2 ; add_edge WH2 -[fixed]-> C2 ;
			add_edge WH2 -[fixed]-> Q2 ;
			del_node WH ; del_node E ; del_node C ; del_node Q ;
			shift E2 ==> CL_HEAD ;
			add_edge V -[obj]-> WH2 ;
			}
		}
	rule qecq_5 { 
		pattern { WH[lemma="que"] ; E[form="est"] ;
			C[form="ce"|"-ce"] ; Q[lemma="que"|"qui"] ;
			WH < E ; E < C ; C < Q }
		without { WH -[fixed]-> E ; WH -[fixed]-> C ; WH -[fixed]-> Q } % Avoiding looping
		without { WH -[dislocated]-> N }
		pattern { h: E -[1=advcl|dislocated|ccomp]-> CL_HEAD }
		pattern { Q[lemma="que"] }
		without { CL_HEAD -[xcomp]-> V }
		commands {
			add_node WH2 :< WH ; add_node E2 :> WH ;
			add_node C2 :> E2 ; add_node Q2 :> C2 ;
			append_feats WH ==> WH2 ; shift WH ==> WH2 ; WH2.ExtPos = "PRON" ;
			shift E ==> E2 ;
			WH2.form = WH.form ; WH2.lemma = WH.lemma ; WH2.upos = WH.upos ;
			append_feats E ==> E2 ;
			E2.form = E.form ; E2.lemma = E.lemma ; E2.upos = E.upos ;
			append_feats C ==> C2 ;
			C2.form = C.form ; C2.lemma = C.lemma ; C2.upos = C.upos ;
			append_feats Q ==> Q2 ;
			Q2.form = Q.form ; Q2.lemma = Q.lemma ; Q2.upos = Q.upos ;
			add_edge WH2 -[fixed]-> E2 ; add_edge WH2 -[fixed]-> C2 ;
			add_edge WH2 -[fixed]-> Q2 ;
			del_node WH ; del_node E ; del_node C ; del_node Q ;
			shift E2 ==> CL_HEAD ;
			add_edge CL_HEAD -[obj]-> WH2 ;
			}
		}
	rule qecq_6 { 
		pattern { WH[lemma="que"] ; E[form="est"] ;
			C[form="ce"|"-ce"] ; Q[lemma="que"|"qui"] ;
			WH < E ; E < C ; C < Q }
		without { WH -[fixed]-> E ; WH -[fixed]-> C ; WH -[fixed]-> Q } % Avoiding looping
		without { WH -[dislocated]-> N }
		pattern { h: E -[1=advcl|dislocated|ccomp]-> CL_HEAD }
		pattern { Q[lemma="qui"] }
		commands {
			add_node WH2 :< WH ; add_node E2 :> WH ;
			add_node C2 :> E2 ; add_node Q2 :> C2 ;
			append_feats WH ==> WH2 ; shift WH ==> WH2 ; WH2.ExtPos = "PRON" ;
			shift E ==> E2 ;
			WH2.form = WH.form ; WH2.lemma = WH.lemma ; WH2.upos = WH.upos ;
			append_feats E ==> E2 ;
			E2.form = E.form ; E2.lemma = E.lemma ; E2.upos = E.upos ;
			append_feats C ==> C2 ;
			C2.form = C.form ; C2.lemma = C.lemma ; C2.upos = C.upos ;
			append_feats Q ==> Q2 ;
			Q2.form = Q.form ; Q2.lemma = Q.lemma ; Q2.upos = Q.upos ;
			add_edge WH2 -[fixed]-> E2 ; add_edge WH2 -[fixed]-> C2 ;
			add_edge WH2 -[fixed]-> Q2 ;
			del_node WH ; del_node E ; del_node C ; del_node Q ;
			shift E2 ==> CL_HEAD ;
			add_edge CL_HEAD -[nsubj]-> WH2 ;
			}
		}
	}
strat qecq { Onf(Seq(pkg_qecq)) }

package pkg_ecq { 
	rule ecq_0 { 
		pattern { E[form="est"|"Est"] ; C[form="ce"|"-ce"] ;
			Q[lemma="que"|"qui"] ; E < C ; C < Q }
		without { E -[fixed]-> C ; E -[fixed]-> C } % Avoiding looping
		without { WH[form="qu'"] ; WH < E }
		without { E -[1=obj]-> C } % ignoring sent. like L'amour est ce que tu rayonnes.
		pattern { a : ANCHOR -> E ;
			s : E -[1=nsubj|expl]-> C ;
			d : E -[1=advcl|ccomp]-> CL_HEAD ;
			m : CL_HEAD -[1=mark|obj|xcomp|nsubj]-> Q }
		commands {
			add_node E2 :< E ; add_node C2 :> E2 ; add_node Q2 :> C2 ;
			append_feats E ==> E2 ; E2.ExtPos = "SCONJ" ;
			E2.form = E.form ; E2.lemma = E.lemma ; E2.upos = E.upos ;
			append_feats C ==> C2 ;
			C2.form = C.form ; C2.lemma = C.lemma ; C2.upos = C.upos ;
			append_feats Q ==> Q2 ;
			Q2.form = Q.form ; Q2.lemma = Q.lemma ; Q2.upos = Q.upos ;
			add_edge E2 -[fixed]-> C2 ; add_edge E2 -[fixed]-> Q2 ;
			shift E ==> CL_HEAD ;
			add_edge CL_HEAD -[mark]-> E2 ;
			del_node E ; del_node C ; del_node Q ;
			}
		}
	rule ecq_1 { 
		pattern { E[form="est"|"Est"] ; C[form="ce"|"-ce"] ;
			Q[lemma="que"|"qui"] ; E < C ; C < Q }
		without { E -[fixed]-> C ; E -[fixed]-> C } % Avoiding looping
		without { WH[form="qu'"] ; WH < E }
		without { E -[1=obj]-> C } % ignoring sent. like L'amour est ce que tu rayonnes.
		pattern { c : CL_HEAD -[cop]-> E ;
			s : CL_HEAD -[1=nsubj|expl]-> C ;
			m : CL_HEAD -[1=mark|obj|xcomp|nsubj|case]-> Q }
		commands {
			add_node E2 :< E ; add_node C2 :> E2 ; add_node Q2 :> C2 ;
			append_feats E ==> E2 ; E2.ExtPos = "SCONJ" ;
			E2.form = E.form ; E2.lemma = E.lemma ; E2.upos = E.upos ;
			append_feats C ==> C2 ;
			C2.form = C.form ; C2.lemma = C.lemma ; C2.upos = C.upos ;
			append_feats Q ==> Q2 ;
			Q2.form = Q.form ; Q2.lemma = Q.lemma ; Q2.upos = Q.upos ;
			add_edge E2 -[fixed]-> C2 ; add_edge E2 -[fixed]-> Q2 ;
			shift E ==> CL_HEAD ;
			add_edge CL_HEAD -[mark]-> E2 ;
			del_node E ; del_node C ; del_node Q ;
			}
		}
	rule ecq_2 { 
		pattern { E[form="est"|"Est"] ; C[form="ce"|"-ce"] ;
			Q[lemma="que"|"qui"] ; E < C ; C < Q }
		without { E -[fixed]-> C ; E -[fixed]-> C } % Avoiding looping
		without { WH[form="qu'"] ; WH < E }
		without { E -[1=obj]-> C } % ignoring sent. like L'amour est ce que tu rayonnes.
		pattern { a : ANCHOR -> E ;
			s : E -[1=nsubj|expl]-> C ; m : E -[xcomp]-> Q ;
			d : E -[1=advcl|ccomp]-> CL_HEAD }
		commands {
			add_node E2 :< E ; add_node C2 :> E2 ; add_node Q2 :> C2 ;
			append_feats E ==> E2 ; E2.ExtPos = "SCONJ" ;
			E2.form = E.form ; E2.lemma = E.lemma ; E2.upos = E.upos ;
			append_feats C ==> C2 ;
			C2.form = C.form ; C2.lemma = C.lemma ; C2.upos = C.upos ;
			append_feats Q ==> Q2 ;
			Q2.form = Q.form ; Q2.lemma = Q.lemma ; Q2.upos = Q.upos ;
			add_edge E2 -[fixed]-> C2 ; add_edge E2 -[fixed]-> Q2 ;
			shift E ==> CL_HEAD ;
			add_edge CL_HEAD -[mark]-> E2 ;
			del_node E ; del_node C ; del_node Q ;
			}
		}
	rule ecq_3 { 
		pattern { E[form="est"|"Est"] ; C[form="ce"|"-ce"] ;
			Q[lemma="que"|"qui"] ; E < C ; C < Q }
		without { E -[fixed]-> C ; E -[fixed]-> C } % Avoiding looping
		without { WH[form="qu'"] ; WH < E }
		without { E -[1=obj]-> C } % ignoring sent. like L'amour est ce que tu rayonnes.
		pattern { a : ANCHOR -> Q ;
			s : Q -[1=nsubj|expl]-> C ; c : Q -[cop]-> E }
		commands {
			add_node E2 :< E ; add_node C2 :> E2 ; add_node Q2 :> C2 ;
			append_feats E ==> E2 ; E2.ExtPos = "SCONJ" ;
			E2.form = E.form ; E2.lemma = E.lemma ; E2.upos = E.upos ;
			append_feats C ==> C2 ;
			C2.form = C.form ; C2.lemma = C.lemma ; C2.upos = C.upos ;
			append_feats Q ==> Q2 ;
			Q2.form = Q.form ; Q2.lemma = Q.lemma ; Q2.upos = Q.upos ;
			add_edge E2 -[fixed]-> C2 ; add_edge E2 -[fixed]-> Q2 ;
			shift Q ==> E2 ; shift E ==> E2 ;
			del_node E ; del_node C ; del_node Q ;
			}
		}
	rule ecq_4 { 
		pattern { E[form="est"|"Est"] ; C[form="ce"|"-ce"] ;
			Q[lemma="que"|"qui"] ; E < C ; C < Q }
		without { E -[fixed]-> C ; E -[fixed]-> C } % Avoiding looping
		without { WH[form="qu'"] ; WH < E }
		without { E -[1=obj]-> C } % ignoring sent. like L'amour est ce que tu rayonnes.
		pattern { a : ANCHOR -> E ;
			s : E -[1=nsubj|expl]-> C ; m : E -[xcomp]-> Q }
		without { d : E -[1=advcl|ccomp]-> CL_HEAD }
		commands {
			add_node E2 :< E ; add_node C2 :> E2 ; add_node Q2 :> C2 ;
			append_feats E ==> E2 ; E2.ExtPos = "SCONJ" ;
			E2.form = E.form ; E2.lemma = E.lemma ; E2.upos = E.upos ;
			append_feats C ==> C2 ;
			C2.form = C.form ; C2.lemma = C.lemma ; C2.upos = C.upos ;
			append_feats Q ==> Q2 ;
			Q2.form = Q.form ; Q2.lemma = Q.lemma ; Q2.upos = Q.upos ;
			add_edge E2 -[fixed]-> C2 ; add_edge E2 -[fixed]-> Q2 ;
			shift E ==> E2 ;
			del_node E ; del_node C ; del_node Q ;
			}
		}
	}
strat ecq { Onf(Seq(pkg_ecq)) }

package pkg_quoted_a { 
	rule quoted_a_0 { 
		pattern { e : G -> CL_HEAD ; CL_HEAD[!Quoted] ;
			P[lemma=":"|"«"|"\""|"-"] ; G << P ; P << CL_HEAD ; }
		without { CL_HEAD[upos="PUNCT"] }
		without { P[lemma="\""] ; PP << G ; PP[lemma="\""] } % " as final quote mark (may restrict a little more than necessary)
		pattern { G -[punct]-> P }
		pattern { P[lemma="«"|":"] }
		commands {
			CL_HEAD.Quoted = "Yes"
			}
		}
	rule quoted_a_1 { 
		pattern { e : G -> CL_HEAD ; CL_HEAD[!Quoted] ;
			P[lemma=":"|"«"|"\""|"-"] ; G << P ; P << CL_HEAD ; }
		without { CL_HEAD[upos="PUNCT"] }
		without { P[lemma="\""] ; PP << G ; PP[lemma="\""] } % " as final quote mark (may restrict a little more than necessary)
		pattern { G -[punct]-> P }
		pattern { P[lemma="\""] ;
			CL_HEAD << P2 ; P2[lemma="\""] }
		commands {
			CL_HEAD.Quoted = "Yes"
			}
		}
	rule quoted_a_2 { 
		pattern { e : G -> CL_HEAD ; CL_HEAD[!Quoted] ;
			P[lemma=":"|"«"|"\""|"-"] ; G << P ; P << CL_HEAD ; }
		without { CL_HEAD[upos="PUNCT"] }
		without { P[lemma="\""] ; PP << G ; PP[lemma="\""] } % " as final quote mark (may restrict a little more than necessary)
		pattern { G -[punct]-> P }
		pattern { P[lemma="-"] ;
			CL_HEAD << P2 ; P2[lemma="-"] }
		commands {
			CL_HEAD.Quoted = "Yes"
			}
		}
	rule quoted_a_3 { 
		pattern { e : G -> CL_HEAD ; CL_HEAD[!Quoted] ;
			P[lemma=":"|"«"|"\""|"-"] ; G << P ; P << CL_HEAD ; }
		without { CL_HEAD[upos="PUNCT"] }
		without { P[lemma="\""] ; PP << G ; PP[lemma="\""] } % " as final quote mark (may restrict a little more than necessary)
		pattern { CL_HEAD -[punct]-> P }
		pattern { P[lemma="«"|":"] }
		commands {
			CL_HEAD.Quoted = "Yes"
			}
		}
	rule quoted_a_4 { 
		pattern { e : G -> CL_HEAD ; CL_HEAD[!Quoted] ;
			P[lemma=":"|"«"|"\""|"-"] ; G << P ; P << CL_HEAD ; }
		without { CL_HEAD[upos="PUNCT"] }
		without { P[lemma="\""] ; PP << G ; PP[lemma="\""] } % " as final quote mark (may restrict a little more than necessary)
		pattern { CL_HEAD -[punct]-> P }
		pattern { P[lemma="\""] ;
			CL_HEAD << P2 ; P2[lemma="\""] }
		commands {
			CL_HEAD.Quoted = "Yes"
			}
		}
	rule quoted_a_5 { 
		pattern { e : G -> CL_HEAD ; CL_HEAD[!Quoted] ;
			P[lemma=":"|"«"|"\""|"-"] ; G << P ; P << CL_HEAD ; }
		without { CL_HEAD[upos="PUNCT"] }
		without { P[lemma="\""] ; PP << G ; PP[lemma="\""] } % " as final quote mark (may restrict a little more than necessary)
		pattern { CL_HEAD -[punct]-> P }
		pattern { P[lemma="-"] ;
			CL_HEAD << P2 ; P2[lemma="-"] }
		commands {
			CL_HEAD.Quoted = "Yes"
			}
		}
	}
strat quoted_a { Onf(Seq(pkg_quoted_a)) }

package pkg_quoted_b { 
	rule quoted_b_0 { 
		pattern { e : CL_HEAD -[1=parataxis]-> D ;
			P[lemma="»"|"\""] ; CL_HEAD << P ; P << D ; CL_HEAD[!Quoted] ; }
		without { CL_HEAD[upos="PUNCT"] }
		without { P[lemma="\""] ; D << PP ; PP[lemma="\""] } % " as initial quote mark (may retrict a little more than necessary)
		pattern { G -[punct]-> P }
		pattern { P[lemma="»"] }
		commands {
			CL_HEAD.Quoted = "Yes"
			}
		}
	rule quoted_b_1 { 
		pattern { e : CL_HEAD -[1=parataxis]-> D ;
			P[lemma="»"|"\""] ; CL_HEAD << P ; P << D ; CL_HEAD[!Quoted] ; }
		without { CL_HEAD[upos="PUNCT"] }
		without { P[lemma="\""] ; D << PP ; PP[lemma="\""] } % " as initial quote mark (may retrict a little more than necessary)
		pattern { G -[punct]-> P }
		pattern { P[lemma="\""] ;
			P2 << P ; P2[lemma="\""] }
		commands {
			CL_HEAD.Quoted = "Yes"
			}
		}
	rule quoted_b_2 { 
		pattern { e : CL_HEAD -[1=parataxis]-> D ;
			P[lemma="»"|"\""] ; CL_HEAD << P ; P << D ; CL_HEAD[!Quoted] ; }
		without { CL_HEAD[upos="PUNCT"] }
		without { P[lemma="\""] ; D << PP ; PP[lemma="\""] } % " as initial quote mark (may retrict a little more than necessary)
		pattern { G -[punct]-> P }
		pattern { P < P2 ; P2[lemma=","] }
		commands {
			CL_HEAD.Quoted = "Yes"
			}
		}
	rule quoted_b_3 { 
		pattern { e : CL_HEAD -[1=parataxis]-> D ;
			P[lemma="»"|"\""] ; CL_HEAD << P ; P << D ; CL_HEAD[!Quoted] ; }
		without { CL_HEAD[upos="PUNCT"] }
		without { P[lemma="\""] ; D << PP ; PP[lemma="\""] } % " as initial quote mark (may retrict a little more than necessary)
		pattern { CL_HEAD -[punct]-> P }
		pattern { P[lemma="»"] }
		commands {
			CL_HEAD.Quoted = "Yes"
			}
		}
	rule quoted_b_4 { 
		pattern { e : CL_HEAD -[1=parataxis]-> D ;
			P[lemma="»"|"\""] ; CL_HEAD << P ; P << D ; CL_HEAD[!Quoted] ; }
		without { CL_HEAD[upos="PUNCT"] }
		without { P[lemma="\""] ; D << PP ; PP[lemma="\""] } % " as initial quote mark (may retrict a little more than necessary)
		pattern { CL_HEAD -[punct]-> P }
		pattern { P[lemma="\""] ;
			P2 << P ; P2[lemma="\""] }
		commands {
			CL_HEAD.Quoted = "Yes"
			}
		}
	rule quoted_b_5 { 
		pattern { e : CL_HEAD -[1=parataxis]-> D ;
			P[lemma="»"|"\""] ; CL_HEAD << P ; P << D ; CL_HEAD[!Quoted] ; }
		without { CL_HEAD[upos="PUNCT"] }
		without { P[lemma="\""] ; D << PP ; PP[lemma="\""] } % " as initial quote mark (may retrict a little more than necessary)
		pattern { CL_HEAD -[punct]-> P }
		pattern { P < P2 ; P2[lemma=","] }
		commands {
			CL_HEAD.Quoted = "Yes"
			}
		}
	}
strat quoted_b { Onf(Seq(pkg_quoted_b)) }

package pkg_quoted_c { 
	rule quoted_c_0 { 
		pattern { e : CL_HEAD -[1=parataxis]-> D ;
			P1[lemma="-"] ; P1 << CL_HEAD ; CL_HEAD -[punct]-> P1 ;
			P2[lemma=","] ; CL_HEAD << P2 ; P2 << D ; CL_HEAD[!Quoted] ; }
		without { CL_HEAD[upos="PUNCT"] }
		pattern { G -[punct]-> P2 }
		commands {
			CL_HEAD.Quoted = "Yes"
			}
		}
	rule quoted_c_1 { 
		pattern { e : CL_HEAD -[1=parataxis]-> D ;
			P1[lemma="-"] ; P1 << CL_HEAD ; CL_HEAD -[punct]-> P1 ;
			P2[lemma=","] ; CL_HEAD << P2 ; P2 << D ; CL_HEAD[!Quoted] ; }
		without { CL_HEAD[upos="PUNCT"] }
		pattern { CL_HEAD -[punct]-> P2 }
		commands {
			CL_HEAD.Quoted = "Yes"
			}
		}
	}
strat quoted_c { Onf(Seq(pkg_quoted_c)) }

package pkg_quoted_d { 
	rule quoted_d_0 { 
		pattern { e : G -> CL_HEAD ; CL_HEAD[!Quoted] }
		without { G[InTitle="Yes"] }
		without { G[Title="Yes"] }
		without { e.label = reparandum }
		pattern { CL_HEAD[Title="Yes"] }
		commands {
			CL_HEAD.Quoted = "Yes"
			}
		}
	rule quoted_d_1 { 
		pattern { e : G -> CL_HEAD ; CL_HEAD[!Quoted] }
		without { G[InTitle="Yes"] }
		without { G[Title="Yes"] }
		without { e.label = reparandum }
		pattern { CL_HEAD[InTitle="Yes"] }
		commands {
			CL_HEAD.Quoted = "Yes"
			}
		}
	}
strat quoted_d { Onf(Seq(pkg_quoted_d)) }

package pkg_quoted_e { 
	rule quoted_e_0 { 
		pattern { e : G -[1=parataxis]-> CL_HEAD ;
			P1[lemma="--"|"("] ; P2[lemma="--"|")"] ;
			P1 << CL_HEAD ; CL_HEAD << P2 ; CL_HEAD[!Quoted] ;
			CL_HEAD -> P1 ; CL_HEAD -> P2 }
		without { CL_HEAD[upos="PUNCT"] }
		pattern { P1[lemma="("] ; P2[lemma=")"] }
		commands {
			CL_HEAD.Quoted = "Yes"
			}
		}
	rule quoted_e_1 { 
		pattern { e : G -[1=parataxis]-> CL_HEAD ;
			P1[lemma="--"|"("] ; P2[lemma="--"|")"] ;
			P1 << CL_HEAD ; CL_HEAD << P2 ; CL_HEAD[!Quoted] ;
			CL_HEAD -> P1 ; CL_HEAD -> P2 }
		without { CL_HEAD[upos="PUNCT"] }
		pattern { P1[lemma="--"] ; P2[lemma="--"] }
		commands {
			CL_HEAD.Quoted = "Yes"
			}
		}
	}
strat quoted_e { Onf(Seq(pkg_quoted_e)) }

package pkg_cleft { 
	rule cleft_0 { 
		pattern { C[lemma="ce"] ; E[lemma="être"] ;
			Q[lemma="que"|"qui"|"dont", upos="SCONJ"] ; 
			HEAD -[1=advcl|acl|csubj|ccomp]-> CL_HEAD ;
			HEAD -[cop]-> E ; HEAD -[1=expl|nsubj]-> C ;
			C < E ; E << HEAD ; HEAD << Q ; Q << CL_HEAD }
		pattern { HEAD[PronType="Int",!IntPhrase] ;
			CL_HEAD[!IntClause] }
		commands {
			HEAD.IntPhrase = "Yes" ;
			CL_HEAD.IntClause = "Yes" ; add_edge CL_HEAD -[cue:wh]-> HEAD ;
			}
		}
	rule cleft_1 { 
		pattern { C[lemma="ce"] ; E[lemma="être"] ;
			Q[lemma="que"|"qui"|"dont", upos="SCONJ"] ; 
			HEAD -[1=advcl|acl|csubj|ccomp]-> CL_HEAD ;
			HEAD -[cop]-> E ; HEAD -[1=expl|nsubj]-> C ;
			C < E ; E << HEAD ; HEAD << Q ; Q << CL_HEAD }
		pattern { HEAD[IntClause="Yes"] ;
			CL_HEAD[!IntClause] }
		commands {
			CL_HEAD.IntClause = "Yes" ;
			add_edge CL_HEAD -[cue:wh]-> HEAD ;
			}
		}
	}
strat cleft { Onf(Seq(pkg_cleft)) }

package pkg_wh_edge { 
	rule wh_edge_0 { 
		pattern { WH [PronType="Int"] ; e : PH_HEAD -> WH ;
			PH_HEAD[!IntPhrase] }
		without { e.label = conj } % not conjuncted WH word
		pattern { e.label = det }
		without { G1 [lemma="ne"] ; % n'importe quel constructions
			G2 [form="importe"] ; G1 < G2 ; G2 < WH }
		commands {
			PH_HEAD.IntPhrase = "Yes" ;
			add_edge PH_HEAD -[cue:wh]-> WH
			}
		}
	rule wh_edge_1 { 
		pattern { WH [PronType="Int"] ; e : PH_HEAD -> WH ;
			PH_HEAD[!IntPhrase] }
		without { e.label = conj } % not conjuncted WH word
		pattern { e.label = fixed }
		without { PH_HEAD [lemma="ne"] ; % n'importe WH constructions
			G2 [form="importe"] ; PH_HEAD < G2 ; G2 < WH }
		commands {
			PH_HEAD.IntPhrase = "Yes" ;
			add_edge PH_HEAD -[cue:wh]-> WH
			}
		}
	rule wh_edge_2 { 
		pattern { WH [PronType="Int"] ; e : PH_HEAD -> WH ;
			PH_HEAD[!IntPhrase] }
		without { e.label = conj } % not conjuncted WH word
		pattern { PH_HEAD -[nmod]-> WH ;
			WH -[case]-> D ; D [lemma="de"] ;
			}
		commands {
			PH_HEAD.IntPhrase = "Yes" ;
			add_edge PH_HEAD -[cue:wh]-> WH
			}
		}
	}
strat wh_edge { Onf(Seq(pkg_wh_edge)) }

package pkg_ph_head_pull { 
	rule ph_head_pull_0 { 
		pattern { R[IntPhrase="Yes"] ;
			e : R -[cue:wh]-> W ;
			PH_HEAD -[nmod]->  R ; % maybe obl:mod is ok
			R -[case]-> D ; D[lemma="de"] ; % only de complements
			PH_HEAD -[case]-> K ; % Only PP can be non-trivial WH-phrases
			PH_HEAD << R ; PH_HEAD[!IntPhrase] }
		without { R[Quoted="Yes"] }
		commands {
			del_feat R.IntPhrase ;
			del_edge e ;
			PH_HEAD.IntPhrase = "Yes" ;
			add_edge PH_HEAD -[cue:wh]-> W
			}
		}
	}
strat ph_head_pull { Onf(Seq(pkg_ph_head_pull)) }

package pkg_ph_edge_b { 
	rule ph_edge_b_0 { 
		pattern {
			PH_HEAD[IntPhrase="Yes"] ; PH_HEAD -[cue:wh]-> WH }
		pattern { f : CL_HEAD -[1=obl|nmod]-> PH_HEAD }
		without { CL_HEAD[IntClause] }
		commands {
			CL_HEAD.IntClause = "Yes" ;
				add_edge CL_HEAD -[cue:wh]-> WH
			}
		}
	rule ph_edge_b_1 { 
		pattern {
			PH_HEAD[IntPhrase="Yes"] ; PH_HEAD -[cue:wh]-> WH }
		without { PH_HEAD[IntClause] }
		pattern {
		ANCHOR -[1=root|parataxis|discourse|vocative|reparandum|dislocated|list|orphan]-> PH_HEAD }
		commands {
			PH_HEAD.IntClause = "Yes"
			}
		}
	rule ph_edge_b_2 { 
		pattern {
			PH_HEAD[IntPhrase="Yes"] ; PH_HEAD -[cue:wh]-> WH }
		without { PH_HEAD[IntClause] }
		pattern { PH_HEAD[Quoted="Yes"] }
		commands {
			PH_HEAD.IntClause = "Yes"
			}
		}
	rule ph_edge_b_3 { 
		pattern {
			PH_HEAD[IntPhrase="Yes"] ; PH_HEAD -[cue:wh]-> WH }
		without { PH_HEAD[IntClause] }
		pattern { ANCHOR -[1=obl|obj]-> PH_HEAD ;
			ANCHOR[lemma="savoir"] ; WH[lemma<>"quoi"] }
		commands {
			PH_HEAD.IntClause = "Yes"
			}
		}
	}
strat ph_edge_b { Onf(Seq(pkg_ph_edge_b)) }

package pkg_ph_edge_a { 
	rule ph_edge_a_0 { 
		pattern { WH [PronType="Int",!IntPhrase] ;
			e : CL_HEAD -[1=nsubj|iobj|obj|obl|advmod|nmod|xcomp|advcl]-> WH ;
			CL_HEAD[!IntClause] }
		without { CL_HEAD -[nmod]-> WH ; CL_HEAD -[case]-> K } %% case wh_edge_1_3
		without { WH[Quoted="Yes"] } % case wh_alone_1_1
		without { N [lemma="ne"] ; N < CL_HEAD ; % n'importe WH constructions
			CL_HEAD [form="importe"] ; CL_HEAD < WH }
		without { CL_HEAD -[1=obl|obj]-> WH ; CL_HEAD [lemma="savoir"] } % case wh_alone_1_2
		pattern {
			CL_HEAD -[1=nsubj|iobj|obj|obl|advmod|xcomp]-> WH }
		commands {
			CL_HEAD.IntClause = "Yes" ;
			WH.IntPhrase = "Yes" ;
			add_edge CL_HEAD -[cue:wh]-> WH ;
			}
		}
	rule ph_edge_a_1 { 
		pattern { WH [PronType="Int",!IntPhrase] ;
			e : CL_HEAD -[1=nsubj|iobj|obj|obl|advmod|nmod|xcomp|advcl]-> WH ;
			CL_HEAD[!IntClause] }
		without { CL_HEAD -[nmod]-> WH ; CL_HEAD -[case]-> K } %% case wh_edge_1_3
		without { WH[Quoted="Yes"] } % case wh_alone_1_1
		without { N [lemma="ne"] ; N < CL_HEAD ; % n'importe WH constructions
			CL_HEAD [form="importe"] ; CL_HEAD < WH }
		without { CL_HEAD -[1=obl|obj]-> WH ; CL_HEAD [lemma="savoir"] } % case wh_alone_1_2
		pattern { e.label = nmod ; WH << CL_HEAD }
		commands {
			CL_HEAD.IntClause = "Yes" ;
			WH.IntPhrase = "Yes" ;
			add_edge CL_HEAD -[cue:wh]-> WH ;
			}
		}
	rule ph_edge_a_2 { 
		pattern { WH [PronType="Int",!IntPhrase] ;
			e : CL_HEAD -[1=nsubj|iobj|obj|obl|advmod|nmod|xcomp|advcl]-> WH ;
			CL_HEAD[!IntClause] }
		without { CL_HEAD -[nmod]-> WH ; CL_HEAD -[case]-> K } %% case wh_edge_1_3
		without { WH[Quoted="Yes"] } % case wh_alone_1_1
		without { N [lemma="ne"] ; N < CL_HEAD ; % n'importe WH constructions
			CL_HEAD [form="importe"] ; CL_HEAD < WH }
		without { CL_HEAD -[1=obl|obj]-> WH ; CL_HEAD [lemma="savoir"] } % case wh_alone_1_2
		pattern { e.label = advcl ;
			WH -[cop]-> E ; E.VerbForm = "Part"}
		commands {
			CL_HEAD.IntClause = "Yes" ;
			WH.IntPhrase = "Yes" ;
			add_edge CL_HEAD -[cue:wh]-> WH ;
			}
		}
	}
strat ph_edge_a { Onf(Seq(pkg_ph_edge_a)) }

package pkg_wh_alone { 
	rule wh_alone_0 { 
		pattern { WH [PronType="Int",!IntPhrase,!IntClause] }
		pattern {
		ANCHOR -[1=root|parataxis|discourse|vocative|reparandum|dislocated|list|orphan]-> WH }
		commands {
			WH.IntClause = "Yes" ;
			WH.IntPhrase = "Yes"
			}
		}
	rule wh_alone_1 { 
		pattern { WH [PronType="Int",!IntPhrase,!IntClause] }
		pattern { WH[Quoted="Yes"] }
		commands {
			WH.IntClause = "Yes" ;
			WH.IntPhrase = "Yes"
			}
		}
	rule wh_alone_2 { 
		pattern { WH [PronType="Int",!IntPhrase,!IntClause] }
		pattern { ANCHOR -[1=obl|obj]-> WH ;
			ANCHOR[lemma="savoir"] ; WH[lemma<>"quoi"] }
		commands {
			WH.IntClause = "Yes" ;
			WH.IntPhrase = "Yes"
			}
		}
	}
strat wh_alone { Onf(Seq(pkg_wh_alone)) }

package pkg_cl_head_pull { 
	rule cl_head_pull_0 { 
		pattern { a: CAND -> CUR ; CUR[IntClause="Yes"] ;
			w: CUR -[cue:wh]-> WH }
		without { CUR[Quoted="Yes"] }
		pattern { CAND -[csubj|ccomp|xcomp|advcl|acl]-> CUR }
		pattern { CUR[upos="VERB",VerbForm="Part"] }
		without { CUR -[1=aux]-> AUX ; AUX[VerbForm="Fin"] }
		commands {
			del_feat CUR.IntClause ; CAND.IntClause = "Yes" ;
				del_edge w ; add_edge CAND -[cue:wh]-> WH ;
			}
		}
	rule cl_head_pull_1 { 
		pattern { a: CAND -> CUR ; CUR[IntClause="Yes"] ;
			w: CUR -[cue:wh]-> WH }
		without { CUR[Quoted="Yes"] }
		pattern { CAND -[csubj|ccomp|xcomp|advcl|acl]-> CUR }
		pattern { CUR -[1=aux|cop]-> V ;
			V[upos="VERB",VerbForm="Part"] }
		without { CUR -[1=aux]-> AUX ; AUX[VerbForm="Fin"] }
		commands {
			del_feat CUR.IntClause ; CAND.IntClause = "Yes" ;
				del_edge w ; add_edge CAND -[cue:wh]-> WH ;
			}
		}
	rule cl_head_pull_2 { 
		pattern { a: CAND -> CUR ; CUR[IntClause="Yes"] ;
			w: CUR -[cue:wh]-> WH }
		without { CUR[Quoted="Yes"] }
		pattern { CAND -[csubj|ccomp|xcomp|advcl|acl]-> CUR }
		pattern { CUR -[mark]-> Q ; CL_HEAD[] ;
			Q[upos="SCONJ"] ; Q << CL_HEAD }
		commands {
			del_feat CUR.IntClause ; CAND.IntClause = "Yes" ;
				del_edge w ; add_edge CAND -[cue:wh]-> WH ;
			}
		}
	rule cl_head_pull_3 { 
		pattern { a: CAND -> CUR ; CUR[IntClause="Yes"] ;
			w: CUR -[cue:wh]-> WH }
		without { CUR[Quoted="Yes"] }
		pattern { CAND -[csubj|ccomp|xcomp|advcl|acl]-> CUR }
		pattern { CUR << WH }
		without { CL_HEAD -[cue:wh]-> WH2 }
		without { CL_HEAD -[case]-> A ; A[lemma="suivant"|"selon"] }
		commands {
			del_feat CUR.IntClause ; CAND.IntClause = "Yes" ;
				del_edge w ; add_edge CAND -[cue:wh]-> WH ;
			}
		}
	rule cl_head_pull_4 { 
		pattern { a: CAND -> CUR ; CUR[IntClause="Yes"] ;
			w: CUR -[cue:wh]-> WH }
		without { CUR[Quoted="Yes"] }
		pattern { CAND -[csubj|ccomp|xcomp|advcl|acl]-> CUR }
		pattern { CUR[form="faire"] ; WH[form="quoi"] ;
			WH < CUR ; P < WH ; P[form="pour"] }
		commands {
			del_feat CUR.IntClause ; CAND.IntClause = "Yes" ;
				del_edge w ; add_edge CAND -[cue:wh]-> WH ;
			}
		}
	rule cl_head_pull_5 { 
		pattern { a: CAND -> CUR ; CUR[IntClause="Yes"] ;
			w: CUR -[cue:wh]-> WH }
		without { CUR[Quoted="Yes"] }
		pattern { CAND -[csubj|ccomp|xcomp|advcl|acl]-> CUR }
		pattern { WH << CAND ; CAND << CUR ;
			CAND -[xcomp]-> CUR ; CUR[VerbForm="Inf"] }
		commands {
			del_feat CUR.IntClause ; CAND.IntClause = "Yes" ;
				del_edge w ; add_edge CAND -[cue:wh]-> WH ;
			}
		}
	rule cl_head_pull_6 { 
		pattern { a: CAND -> CUR ; CUR[IntClause="Yes"] ;
			w: CUR -[cue:wh]-> WH }
		without { CUR[Quoted="Yes"] }
		pattern { CAND -[nsubj|obj|obl|nmod|det]-> CUR }
		without { CAND[lemma="savoir"] ; CAND -[obj]-> CUR }
		commands {
			del_feat CUR.IntClause ; CAND.IntClause = "Yes" ;
				del_edge w ; add_edge CAND -[cue:wh]-> WH ;
			}
		}
	}
strat cl_head_pull { Onf(Seq(pkg_cl_head_pull)) }

package pkg_conj { 
	rule conj_0 { 
		pattern { P1 -[conj]-> P2 ; C[IntClause="Yes"] }
		pattern { P1[IntPhrase="Yes",PronType="Int"] ;
			C -[cue:wh]-> P1 }
		pattern { P2[PronType="Int"] }
		without { C -[cue:wh]-> P2 }
		commands {
			add_edge C -[cue:wh]-> P2
			}
		}
	rule conj_1 { 
		pattern { P1 -[conj]-> P2 ; C[IntClause="Yes"] }
		pattern { P1[IntPhrase="Yes",PronType="Int"] ;
			C -[cue:wh]-> P1 }
		pattern { P2[IntPhrase="Yes"] ; P2 -[cue:wh]-> WH2 }
		without { C -[cue:wh]-> WH2 }
		commands {
			add_edge C -[cue:wh]-> WH2
			}
		}
	rule conj_2 { 
		pattern { P1 -[conj]-> P2 ; C[IntClause="Yes"] }
		pattern { P1[IntPhrase="Yes"] ;
			P1 -[cue:wh]-> WH1 ; C -[cue:wh]-> WH1 }
		pattern { P2[PronType="Int"] }
		without { C -[cue:wh]-> P2 }
		commands {
			add_edge C -[cue:wh]-> P2
			}
		}
	rule conj_3 { 
		pattern { P1 -[conj]-> P2 ; C[IntClause="Yes"] }
		pattern { P1[IntPhrase="Yes"] ;
			P1 -[cue:wh]-> WH1 ; C -[cue:wh]-> WH1 }
		pattern { P2[IntPhrase="Yes"] ; P2 -[cue:wh]-> WH2 }
		without { C -[cue:wh]-> WH2 }
		commands {
			add_edge C -[cue:wh]-> WH2
			}
		}
	}
strat conj { Onf(Seq(pkg_conj)) }

package pkg_eske { 
	rule eske_0 { 
		pattern { N1[form="est"|"Est"] ; N2[form="ce"|"-ce"] ;
			N1 < N2 ; N1 -[fixed]-> N2  }
		without { Q [form="qu'"] ; Q < N1 }
		pattern { CL_HEAD -[mark]-> N1 ; }
		without { CL_HEAD -[cue:mark]-> N1 } % no loop 
		commands {
			CL_HEAD.IntClause = "Yes" ;
				add_edge CL_HEAD -[cue:mark]-> N1 ; 
			}
		}
	rule eske_1 { 
		pattern { N1[form="est"|"Est"] ; N2[form="ce"|"-ce"] ;
			N1 < N2 ; N1 -[fixed]-> N2  }
		without { Q [form="qu'"] ; Q < N1 }
		without { CL_HEAD -[mark]-> N1 ; N1[!IntClause] }
		without { N1.IntClause = "Yes"} % no loop 
		commands {
			N1.IntClause = "Yes" ;
			}
		}
	rule eske_2 { 
		pattern { N1[form="ce"|"-ce"] ;
			N2 [form="que"] ; N1 < N2 ; N1 -[fixed]-> N2 }
		pattern { CL_HEAD -[mark]-> N1 ; }
		without { CL_HEAD -[cue:mark]-> N1 } % no loop 
		commands {
			CL_HEAD.IntClause = "Yes" ;
				add_edge CL_HEAD -[cue:mark]-> N1 ; 
			}
		}
	rule eske_3 { 
		pattern { N1[form="ce"|"-ce"] ;
			N2 [form="que"] ; N1 < N2 ; N1 -[fixed]-> N2 }
		without { CL_HEAD -[mark]-> N1 ; N1[!IntClause] }
		without { N1.IntClause = "Yes"} % no loop 
		commands {
			N1.IntClause = "Yes" ;
			}
		}
	}
strat eske { Onf(Seq(pkg_eske)) }

package pkg_que { 
	rule que_0 { 
		pattern { Q[lemma="que"] ; WH[PronType="Int"] ;
			WH << Q }
		pattern { WH -[mark|xcomp]-> Q }
		without { WH -[cue:mark]-> Q }
		commands {
			add_edge WH -[cue:mark]-> Q
			}
		}
	}
strat que { Onf(Seq(pkg_que)) }

package pkg_si { 
	rule si_0 { 
		pattern {a: ANCHOR -[advcl|acl|ccomp|nsubj]-> CL_HEAD ;
			m: CL_HEAD -[mark]-> S ; S[lemma="si",upos="SCONJ"] ; CL_HEAD[!IntClause] }
		without { M[lemma="même"] ; M < S }
		without { Q[upos=SCONJ] ; Q < S ; CL_HEAD -[mark]-> Q }
		without { CL_HEAD -[cue:mark]-> S  } % no loop
		pattern { CL_HEAD[upos="VERB",VerbForm="Fin"] }
		pattern { ANCHOR -[ccomp]-> CL_HEAD }
		commands {
			CL_HEAD.IntClause = "Yes" ;
				add_edge CL_HEAD -[cue:mark]-> S ;
			}
		}
	rule si_1 { 
		pattern {a: ANCHOR -[advcl|acl|ccomp|nsubj]-> CL_HEAD ;
			m: CL_HEAD -[mark]-> S ; S[lemma="si",upos="SCONJ"] ; CL_HEAD[!IntClause] }
		without { M[lemma="même"] ; M < S }
		without { Q[upos=SCONJ] ; Q < S ; CL_HEAD -[mark]-> Q }
		without { CL_HEAD -[cue:mark]-> S  } % no loop
		pattern { CL_HEAD[upos="VERB",VerbForm="Fin"] }
		pattern { ANCHOR -[advcl|acl]-> CL_HEAD ; C[upos="ADP"] ;
			CL_HEAD -[case]-> C ; C < S }
		commands {
			CL_HEAD.IntClause = "Yes" ;
				add_edge CL_HEAD -[cue:mark]-> S ;
			}
		}
	rule si_2 { 
		pattern {a: ANCHOR -[advcl|acl|ccomp|nsubj]-> CL_HEAD ;
			m: CL_HEAD -[mark]-> S ; S[lemma="si",upos="SCONJ"] ; CL_HEAD[!IntClause] }
		without { M[lemma="même"] ; M < S }
		without { Q[upos=SCONJ] ; Q < S ; CL_HEAD -[mark]-> Q }
		without { CL_HEAD -[cue:mark]-> S  } % no loop
		pattern { CL_HEAD[upos="VERB",VerbForm="Fin"] }
		pattern { a.label = nsubj ; CL_HEAD << ANCHOR }
		commands {
			CL_HEAD.IntClause = "Yes" ;
				add_edge CL_HEAD -[cue:mark]-> S ;
			}
		}
	rule si_3 { 
		pattern {a: ANCHOR -[advcl|acl|ccomp|nsubj]-> CL_HEAD ;
			m: CL_HEAD -[mark]-> S ; S[lemma="si",upos="SCONJ"] ; CL_HEAD[!IntClause] }
		without { M[lemma="même"] ; M < S }
		without { Q[upos=SCONJ] ; Q < S ; CL_HEAD -[mark]-> Q }
		without { CL_HEAD -[cue:mark]-> S  } % no loop
		pattern { CL_HEAD -[1=aux|cop]-> V ;
			V[upos="VERB",VerbForm="Fin"] }
		pattern { ANCHOR -[ccomp]-> CL_HEAD }
		commands {
			CL_HEAD.IntClause = "Yes" ;
				add_edge CL_HEAD -[cue:mark]-> S ;
			}
		}
	rule si_4 { 
		pattern {a: ANCHOR -[advcl|acl|ccomp|nsubj]-> CL_HEAD ;
			m: CL_HEAD -[mark]-> S ; S[lemma="si",upos="SCONJ"] ; CL_HEAD[!IntClause] }
		without { M[lemma="même"] ; M < S }
		without { Q[upos=SCONJ] ; Q < S ; CL_HEAD -[mark]-> Q }
		without { CL_HEAD -[cue:mark]-> S  } % no loop
		pattern { CL_HEAD -[1=aux|cop]-> V ;
			V[upos="VERB",VerbForm="Fin"] }
		pattern { ANCHOR -[advcl|acl]-> CL_HEAD ; C[upos="ADP"] ;
			CL_HEAD -[case]-> C ; C < S }
		commands {
			CL_HEAD.IntClause = "Yes" ;
				add_edge CL_HEAD -[cue:mark]-> S ;
			}
		}
	rule si_5 { 
		pattern {a: ANCHOR -[advcl|acl|ccomp|nsubj]-> CL_HEAD ;
			m: CL_HEAD -[mark]-> S ; S[lemma="si",upos="SCONJ"] ; CL_HEAD[!IntClause] }
		without { M[lemma="même"] ; M < S }
		without { Q[upos=SCONJ] ; Q < S ; CL_HEAD -[mark]-> Q }
		without { CL_HEAD -[cue:mark]-> S  } % no loop
		pattern { CL_HEAD -[1=aux|cop]-> V ;
			V[upos="VERB",VerbForm="Fin"] }
		pattern { a.label = nsubj ; CL_HEAD << ANCHOR }
		commands {
			CL_HEAD.IntClause = "Yes" ;
				add_edge CL_HEAD -[cue:mark]-> S ;
			}
		}
	}
strat si { Onf(Seq(pkg_si)) }

package pkg_titu { 
	rule titu_0 { 
		pattern { CL_HEAD -[mark]-> T ;
			T[form="tu"|"-tu"|"ti"|"-ti"] ; CL_HEAD[!IntClause] }
		without { CL_HEAD -[cue:mark]-> T } % no loop
		commands {
			CL_HEAD.IntClause = "Yes" ;
			    add_edge CL_HEAD -[cue:mark]-> T
			}
		}
	}
strat titu { Onf(Seq(pkg_titu)) }

package pkg_spp { 
	rule spp_0 { 
		pattern { S[upos="PRON"] ;
		    S[lemma="ce"|"je"|"tu"|"il"|"elle"|"on"|"nous"|"vous"|"ils"|"elles"] ;
		    s: CL_HEAD -[1=expl|nsubj]-> S ; }
		without { CL_HEAD -[1=parataxis]-> G ; G[Quoted="Yes"] } % no verb-reporting stylistic inversion
		without { G -[1=parataxis]-> CL_HEAD ; G[Quoted="Yes"] } % no verb-reporting stylistic inversion
		without { CL_HEAD -[expl:comp]-> S } % no object S
		without { A[upos="ADV", lemma <> "ne"|"pourquoi"|"où"|"comment"|"quand"] ;
		    CL_HEAD -[advmod]-> A ; A << CL_HEAD } % No non-interrogative preceding adverb
		without { A[ExtPos="ADV", lemma <> "ne"|"pourquoi"|"où"|"comment"|"quand"] ;
		    CL_HEAD -[advmod]-> A ; A << CL_HEAD } % No non-interrogative preceding adverbial phrase
		without { CL_HEAD -[cue:mark]-> S } % avoid looping
		
		pattern { CL_HEAD[upos="VERB"|"AUX", VerbForm="Fin"] ;
			CL_HEAD < S ; }
		without { CL_HEAD[Mood="Imp"] } % not imperative
		without { ANCHOR -[1=parataxis]-> CL_HEAD }
		commands {
			CL_HEAD.IntClause = "Yes" ;
			    add_edge CL_HEAD -[cue:mark]-> S ;
			}
		}
	rule spp_1 { 
		pattern { S[upos="PRON"] ;
		    S[lemma="ce"|"je"|"tu"|"il"|"elle"|"on"|"nous"|"vous"|"ils"|"elles"] ;
		    s: CL_HEAD -[1=expl|nsubj]-> S ; }
		without { CL_HEAD -[1=parataxis]-> G ; G[Quoted="Yes"] } % no verb-reporting stylistic inversion
		without { G -[1=parataxis]-> CL_HEAD ; G[Quoted="Yes"] } % no verb-reporting stylistic inversion
		without { CL_HEAD -[expl:comp]-> S } % no object S
		without { A[upos="ADV", lemma <> "ne"|"pourquoi"|"où"|"comment"|"quand"] ;
		    CL_HEAD -[advmod]-> A ; A << CL_HEAD } % No non-interrogative preceding adverb
		without { A[ExtPos="ADV", lemma <> "ne"|"pourquoi"|"où"|"comment"|"quand"] ;
		    CL_HEAD -[advmod]-> A ; A << CL_HEAD } % No non-interrogative preceding adverbial phrase
		without { CL_HEAD -[cue:mark]-> S } % avoid looping
		
		pattern { CL_HEAD[upos="VERB"|"AUX", VerbForm="Fin"] ;
			CL_HEAD < S ; }
		without { CL_HEAD[Mood="Imp"] } % not imperative
		pattern { ANCHOR -[1=parataxis]-> CL_HEAD ;
			CL_HEAD -[1=nsubj|obj|obl|ccomp]-> U }
		commands {
			CL_HEAD.IntClause = "Yes" ;
			    add_edge CL_HEAD -[cue:mark]-> S ;
			}
		}
	rule spp_2 { 
		pattern { S[upos="PRON"] ;
		    S[lemma="ce"|"je"|"tu"|"il"|"elle"|"on"|"nous"|"vous"|"ils"|"elles"] ;
		    s: CL_HEAD -[1=expl|nsubj]-> S ; }
		without { CL_HEAD -[1=parataxis]-> G ; G[Quoted="Yes"] } % no verb-reporting stylistic inversion
		without { G -[1=parataxis]-> CL_HEAD ; G[Quoted="Yes"] } % no verb-reporting stylistic inversion
		without { CL_HEAD -[expl:comp]-> S } % no object S
		without { A[upos="ADV", lemma <> "ne"|"pourquoi"|"où"|"comment"|"quand"] ;
		    CL_HEAD -[advmod]-> A ; A << CL_HEAD } % No non-interrogative preceding adverb
		without { A[ExtPos="ADV", lemma <> "ne"|"pourquoi"|"où"|"comment"|"quand"] ;
		    CL_HEAD -[advmod]-> A ; A << CL_HEAD } % No non-interrogative preceding adverbial phrase
		without { CL_HEAD -[cue:mark]-> S } % avoid looping
		
		pattern { CL_HEAD[upos="VERB"|"AUX", VerbForm="Fin"] ;
			CL_HEAD < S ; }
		without { CL_HEAD[Mood="Imp"] } % not imperative
		pattern { ANCHOR -[1=parataxis]-> CL_HEAD ;
			CL_HEAD -[cue:wh]-> WH ; WH << CL_HEAD }
		commands {
			CL_HEAD.IntClause = "Yes" ;
			    add_edge CL_HEAD -[cue:mark]-> S ;
			}
		}
	rule spp_3 { 
		pattern { S[upos="PRON"] ;
		    S[lemma="ce"|"je"|"tu"|"il"|"elle"|"on"|"nous"|"vous"|"ils"|"elles"] ;
		    s: CL_HEAD -[1=expl|nsubj]-> S ; }
		without { CL_HEAD -[1=parataxis]-> G ; G[Quoted="Yes"] } % no verb-reporting stylistic inversion
		without { G -[1=parataxis]-> CL_HEAD ; G[Quoted="Yes"] } % no verb-reporting stylistic inversion
		without { CL_HEAD -[expl:comp]-> S } % no object S
		without { A[upos="ADV", lemma <> "ne"|"pourquoi"|"où"|"comment"|"quand"] ;
		    CL_HEAD -[advmod]-> A ; A << CL_HEAD } % No non-interrogative preceding adverb
		without { A[ExtPos="ADV", lemma <> "ne"|"pourquoi"|"où"|"comment"|"quand"] ;
		    CL_HEAD -[advmod]-> A ; A << CL_HEAD } % No non-interrogative preceding adverbial phrase
		without { CL_HEAD -[cue:mark]-> S } % avoid looping
		
		pattern { CL_HEAD[upos="VERB"|"AUX", VerbForm="Fin"] ;
			CL_HEAD < S ; }
		without { CL_HEAD[Mood="Imp"] } % not imperative
		pattern { ANCHOR -[1=parataxis]-> CL_HEAD ;
			CL_HEAD -[xcomp]-> U ;
			U -[1=obj|obl|ccomp]-> W }
		commands {
			CL_HEAD.IntClause = "Yes" ;
			    add_edge CL_HEAD -[cue:mark]-> S ;
			}
		}
	rule spp_4 { 
		pattern { S[upos="PRON"] ;
		    S[lemma="ce"|"je"|"tu"|"il"|"elle"|"on"|"nous"|"vous"|"ils"|"elles"] ;
		    s: CL_HEAD -[1=expl|nsubj]-> S ; }
		without { CL_HEAD -[1=parataxis]-> G ; G[Quoted="Yes"] } % no verb-reporting stylistic inversion
		without { G -[1=parataxis]-> CL_HEAD ; G[Quoted="Yes"] } % no verb-reporting stylistic inversion
		without { CL_HEAD -[expl:comp]-> S } % no object S
		without { A[upos="ADV", lemma <> "ne"|"pourquoi"|"où"|"comment"|"quand"] ;
		    CL_HEAD -[advmod]-> A ; A << CL_HEAD } % No non-interrogative preceding adverb
		without { A[ExtPos="ADV", lemma <> "ne"|"pourquoi"|"où"|"comment"|"quand"] ;
		    CL_HEAD -[advmod]-> A ; A << CL_HEAD } % No non-interrogative preceding adverbial phrase
		without { CL_HEAD -[cue:mark]-> S } % avoid looping
		
		pattern { CL_HEAD -[1=cop|aux]-> V ;
			V[upos="VERB"|"AUX", VerbForm="Fin"] ; V < S }
		without { V[Mood="Imp"] } % not imperative
		without { ANCHOR -[1=parataxis]-> CL_HEAD }
		commands {
			CL_HEAD.IntClause = "Yes" ;
			    add_edge CL_HEAD -[cue:mark]-> S ;
			}
		}
	rule spp_5 { 
		pattern { S[upos="PRON"] ;
		    S[lemma="ce"|"je"|"tu"|"il"|"elle"|"on"|"nous"|"vous"|"ils"|"elles"] ;
		    s: CL_HEAD -[1=expl|nsubj]-> S ; }
		without { CL_HEAD -[1=parataxis]-> G ; G[Quoted="Yes"] } % no verb-reporting stylistic inversion
		without { G -[1=parataxis]-> CL_HEAD ; G[Quoted="Yes"] } % no verb-reporting stylistic inversion
		without { CL_HEAD -[expl:comp]-> S } % no object S
		without { A[upos="ADV", lemma <> "ne"|"pourquoi"|"où"|"comment"|"quand"] ;
		    CL_HEAD -[advmod]-> A ; A << CL_HEAD } % No non-interrogative preceding adverb
		without { A[ExtPos="ADV", lemma <> "ne"|"pourquoi"|"où"|"comment"|"quand"] ;
		    CL_HEAD -[advmod]-> A ; A << CL_HEAD } % No non-interrogative preceding adverbial phrase
		without { CL_HEAD -[cue:mark]-> S } % avoid looping
		
		pattern { CL_HEAD -[1=cop|aux]-> V ;
			V[upos="VERB"|"AUX", VerbForm="Fin"] ; V < S }
		without { V[Mood="Imp"] } % not imperative
		pattern { ANCHOR -[1=parataxis]-> CL_HEAD ;
			CL_HEAD -[1=nsubj|obj|obl|ccomp]-> U }
		commands {
			CL_HEAD.IntClause = "Yes" ;
			    add_edge CL_HEAD -[cue:mark]-> S ;
			}
		}
	rule spp_6 { 
		pattern { S[upos="PRON"] ;
		    S[lemma="ce"|"je"|"tu"|"il"|"elle"|"on"|"nous"|"vous"|"ils"|"elles"] ;
		    s: CL_HEAD -[1=expl|nsubj]-> S ; }
		without { CL_HEAD -[1=parataxis]-> G ; G[Quoted="Yes"] } % no verb-reporting stylistic inversion
		without { G -[1=parataxis]-> CL_HEAD ; G[Quoted="Yes"] } % no verb-reporting stylistic inversion
		without { CL_HEAD -[expl:comp]-> S } % no object S
		without { A[upos="ADV", lemma <> "ne"|"pourquoi"|"où"|"comment"|"quand"] ;
		    CL_HEAD -[advmod]-> A ; A << CL_HEAD } % No non-interrogative preceding adverb
		without { A[ExtPos="ADV", lemma <> "ne"|"pourquoi"|"où"|"comment"|"quand"] ;
		    CL_HEAD -[advmod]-> A ; A << CL_HEAD } % No non-interrogative preceding adverbial phrase
		without { CL_HEAD -[cue:mark]-> S } % avoid looping
		
		pattern { CL_HEAD -[1=cop|aux]-> V ;
			V[upos="VERB"|"AUX", VerbForm="Fin"] ; V < S }
		without { V[Mood="Imp"] } % not imperative
		pattern { ANCHOR -[1=parataxis]-> CL_HEAD ;
			CL_HEAD -[cue:wh]-> WH ; WH << CL_HEAD }
		commands {
			CL_HEAD.IntClause = "Yes" ;
			    add_edge CL_HEAD -[cue:mark]-> S ;
			}
		}
	rule spp_7 { 
		pattern { S[upos="PRON"] ;
		    S[lemma="ce"|"je"|"tu"|"il"|"elle"|"on"|"nous"|"vous"|"ils"|"elles"] ;
		    s: CL_HEAD -[1=expl|nsubj]-> S ; }
		without { CL_HEAD -[1=parataxis]-> G ; G[Quoted="Yes"] } % no verb-reporting stylistic inversion
		without { G -[1=parataxis]-> CL_HEAD ; G[Quoted="Yes"] } % no verb-reporting stylistic inversion
		without { CL_HEAD -[expl:comp]-> S } % no object S
		without { A[upos="ADV", lemma <> "ne"|"pourquoi"|"où"|"comment"|"quand"] ;
		    CL_HEAD -[advmod]-> A ; A << CL_HEAD } % No non-interrogative preceding adverb
		without { A[ExtPos="ADV", lemma <> "ne"|"pourquoi"|"où"|"comment"|"quand"] ;
		    CL_HEAD -[advmod]-> A ; A << CL_HEAD } % No non-interrogative preceding adverbial phrase
		without { CL_HEAD -[cue:mark]-> S } % avoid looping
		
		pattern { CL_HEAD -[1=cop|aux]-> V ;
			V[upos="VERB"|"AUX", VerbForm="Fin"] ; V < S }
		without { V[Mood="Imp"] } % not imperative
		pattern { ANCHOR -[1=parataxis]-> CL_HEAD ;
			CL_HEAD -[xcomp]-> U ;
			U -[1=obj|obl|ccomp]-> W }
		commands {
			CL_HEAD.IntClause = "Yes" ;
			    add_edge CL_HEAD -[cue:mark]-> S ;
			}
		}
	}
strat spp { Onf(Seq(pkg_spp)) }

strat main { Seq(telquel,nimporte,whque,relprontype,intprontype,qecq,ecq,quoted_a,quoted_b,quoted_c,quoted_d,quoted_e,cleft,wh_edge,cleft,ph_head_pull,cleft,ph_edge_b,ph_edge_a,wh_alone,cl_head_pull,conj,eske,que,si,titu,spp) }